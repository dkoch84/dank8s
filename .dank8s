#!/bin/bash

function kubehelp {
  BOLD="$(tput bold)"
  BLUE="$(tput setaf 4)"
  NC="$(tput sgr0)"
  cat <<EOF
${BOLD}Dank Kubernetes Helpers${NC}

${BLUE}Setup${NC}
  ns <namespace>              Set kubectl namespace
  kubeall on|off              Toggle all-namespaces mode

${BLUE}List Resources${NC}
  pods|deployments|services|nodes|events|ingresses|endpoints
  configmaps|secrets|certificates|issuers|orders|daemonsets
  statefulsets|jobs|cronjobs|replicasets|pvcs|pvs|storageclasses
  networkpolicies|serviceaccounts|namespaces

  Shortcuts: deps|svcs|ings|eps|cms|certs|ds|sts|cjs|rs,
            netpols|sas|nss|sc

${BLUE}Inspect Resources${NC}
  pod|deployment|service|node|ingress|endpoint|configmap|secret
  certificate|issuer|order|daemonset|statefulset|job|cronjob
  replicaset|pvc|pv|storageclass|networkpolicy|serviceaccount|namespace

  Usage: <type> <name>  (auto-detects namespace|shows interactive menu)
  Shortcuts: dep|svc|ing|ep|cm|cert|ds|sts|cj|rs|netpol|sa

${BLUE}Actions${NC}
  exec <pod>                  Open shell in pod
  rollout <deployment>        Restart deployment
  logs <pod>                  View pod logs
  watch <resource|command>    Auto-refresh view (press 'q' to quit)

${BLUE}Utilities${NC}
  refresh <command>           Clear screen and run command
  kubehelp                    Show this help
  unkube                      Remove all helpers
EOF
}

function unkube {
  unset ns
  unset refresh
  unset watch
  unset pods
  unset pod
  unset deployments
  unset deployment
  unset deps
  unset dep
  unset services
  unset service
  unset svcs
  unset svc
  unset nodes
  unset node
  unset events
  unset exec
  unset rollout
  unset logs
  unset khelper
  unset kubehelp
  unset unkube
  unset ingresses
  unset ingress
  unset ings
  unset ing
  unset endpoints
  unset endpoint
  unset eps
  unset ep
  unset configmaps
  unset configmap
  unset cms
  unset cm
  unset secrets
  unset secret
  unset certificates
  unset certificate
  unset certs
  unset cert
  unset issuers
  unset issuer
  unset orders
  unset order
  unset daemonsets
  unset daemonset
  unset ds
  unset statefulsets
  unset statefulset
  unset sts
  unset jobs
  unset job
  unset cronjobs
  unset cronjob
  unset cjs
  unset cj
  unset replicasets
  unset replicaset
  unset rs
  unset persistentvolumeclaims
  unset persistentvolumeclaim
  unset pvcs
  unset pvc
  unset persistentvolumes
  unset persistentvolume
  unset pvs
  unset pv
  unset storageclasses
  unset storageclass
  unset sc
  unset networkpolicies
  unset networkpolicy
  unset netpols
  unset netpol
  unset serviceaccounts
  unset serviceaccount
  unset sas
  unset sa
  unset namespaces
  unset namespace
  unset nss
  unset kubeall
  unset KUBEALL
  unset pluralize_resource

  # Remove completions
  complete -r pod exec logs deployment dep rollout service svc 2>/dev/null
  complete -r ingress ing endpoint ep configmap cm secret certificate cert 2>/dev/null
  complete -r issuer order daemonset statefulset sts job cronjob cj 2>/dev/null
  complete -r replicaset rs persistentvolumeclaim pvc persistentvolume pv 2>/dev/null
  complete -r storageclass networkpolicy netpol serviceaccount sa 2>/dev/null
  complete -r node ns namespace watch kubeall 2>/dev/null
}

function kubeall {
  case "$1" in
    "on")
      export KUBEALL="-A"
      echo "All-namespaces mode enabled. Commands will show resources from all namespaces by default."
      ;;
    "off")
      export KUBEALL=""
      echo "All-namespaces mode disabled. Commands will show resources from current namespace."
      ;;
    "")
      if [ -n "$KUBEALL" ]; then
        echo "All-namespaces mode is ON"
      else
        echo "All-namespaces mode is OFF"
      fi
      ;;
    *)
      echo "Usage: kubeall [on|off]"
      echo "  on  - Show resources from all namespaces by default"
      echo "  off - Show resources from current namespace only"
      echo "  (no args) - Show current status"
      ;;
  esac
}

function pluralize_resource {
  declare -A plurals=(
    [ingress]="ingresses"
    [endpoint]="endpoints"
    [configmap]="configmaps"
    [secret]="secrets"
    [pod]="pods"
    [deployment]="deployments"
    [service]="services"
    [node]="nodes"
    [certificate]="certificates"
    [issuer]="issuers"
    [order]="orders"
    [daemonset]="daemonsets"
    [statefulset]="statefulsets"
    [job]="jobs"
    [cronjob]="cronjobs"
    [replicaset]="replicasets"
    [persistentvolumeclaim]="persistentvolumeclaims"
    [persistentvolume]="persistentvolumes"
    [storageclass]="storageclasses"
    [networkpolicy]="networkpolicies"
    [serviceaccount]="serviceaccounts"
    [namespace]="namespaces"
  )
  local singular="$1"
  echo "${plurals[$singular]:-${singular}s}"
}

function ns {
  kubectl config set-context --current --namespace="$1"
}

function refresh {
  tput clear;
  bash -ic "$@";
}

function khelper {
  local resource
  if [ "${FUNCNAME[1]}" != "exec" ] && [ "${FUNCNAME[1]}" != "logs" ]; then
    resource=$(pluralize_resource "${FUNCNAME[1]}")
    data=$(kubectl get "$resource" -A --no-headers)
  else
    data=$(kubectl get pods -A --no-headers)
  fi
  echo "$(awk -v name="$1" '$2 == name {print $1}' <<< "$data")"
}

function watch {
  case "$1" in
    "pods")
      CMD="kubectl get pods $KUBEALL ${@:2} --force-colors"
      ;;
    "deployments")
      CMD="kubectl get deployments $KUBEALL ${@:2} --force-colors"
      ;;
    "services")
      CMD="kubectl get services $KUBEALL ${@:2} --force-colors"
      ;;
    "nodes")
      CMD="kubectl get nodes ${@:2} --force-colors"
      ;;
    "events")
      CMD="kubectl get events $KUBEALL --sort-by=.metadata.creationTimestamp ${@:2} --force-colors"
      ;;
    "ingresses")
      CMD="kubectl get ingresses $KUBEALL ${@:2} --force-colors"
      ;;
    "endpoints")
      CMD="kubectl get endpoints $KUBEALL ${@:2} --force-colors"
      ;;
    "configmaps")
      CMD="kubectl get configmaps $KUBEALL ${@:2} --force-colors"
      ;;
    "secrets")
      CMD="kubectl get secrets $KUBEALL ${@:2} --force-colors"
      ;;
    "certificates")
      CMD="kubectl get certificates $KUBEALL ${@:2} --force-colors"
      ;;
    "issuers")
      CMD="kubectl get issuers $KUBEALL ${@:2} --force-colors"
      ;;
    "orders")
      CMD="kubectl get orders $KUBEALL ${@:2} --force-colors"
      ;;
    "daemonsets"|"ds")
      CMD="kubectl get daemonsets $KUBEALL ${@:2} --force-colors"
      ;;
    "statefulsets"|"sts")
      CMD="kubectl get statefulsets $KUBEALL ${@:2} --force-colors"
      ;;
    "jobs")
      CMD="kubectl get jobs $KUBEALL ${@:2} --force-colors"
      ;;
    "cronjobs"|"cjs")
      CMD="kubectl get cronjobs $KUBEALL ${@:2} --force-colors"
      ;;
    "replicasets"|"rs")
      CMD="kubectl get replicasets $KUBEALL ${@:2} --force-colors"
      ;;
    "persistentvolumeclaims"|"pvcs")
      CMD="kubectl get persistentvolumeclaims $KUBEALL ${@:2} --force-colors"
      ;;
    "persistentvolumes"|"pvs")
      CMD="kubectl get persistentvolumes ${@:2} --force-colors"
      ;;
    "storageclasses"|"sc")
      CMD="kubectl get storageclasses ${@:2} --force-colors"
      ;;
    "networkpolicies"|"netpols")
      CMD="kubectl get networkpolicies $KUBEALL ${@:2} --force-colors"
      ;;
    "serviceaccounts"|"sas")
      CMD="kubectl get serviceaccounts $KUBEALL ${@:2} --force-colors"
      ;;
    "namespaces"|"nss")
      CMD="kubectl get namespaces ${@:2} --force-colors"
      ;;
    *)
      CMD="$@"
      ;;
  esac

  # Set terminal to raw mode for input detection
  stty -echo -icanon

  # Trap to restore terminal settings on exit
  trap 'stty sane' EXIT INT TERM

  while true; do
    # Use refresh to clear and run command
    output=$(tput clear; echo "Watching $1 - Press 'q' to quit"; echo; bash -ic "$CMD")
    printf '%s' "$output"

    # Check for 'q' keypress with 1 second timeout
    if read -t 1 -n 1 key; then
      if [[ "$key" == "q" ]]; then
        stty sane
        echo
        break
      fi
    fi
  done;

  # Restore terminal settings
  stty sane
  trap - EXIT INT TERM
}

function exec {
  namespace=$(khelper "$1")
  if ! kubectl exec -it -n "${namespace}" "$1" -- /bin/bash 2>/dev/null; then
    echo "Falling back to /bin/sh..."
    kubectl exec -it -n "${namespace}" "$1" -- /bin/sh
  fi
}

function rollout {
  namespace=$(khelper "$1")
  kubectl rollout restart deployment -n "${namespace}" "$1"
}

function pods {
  kubectl get pods $KUBEALL $@
}

function deployments {
  kubectl get deployments $KUBEALL $@
}

function services {
  kubectl get services $KUBEALL $@
}

function nodes {
  kubectl get nodes ${@:1}
}

function events {
  kubectl get events $KUBEALL --sort-by=.metadata.creationTimestamp $@
}

function ingresses {
  kubectl get ingresses $KUBEALL $@
}

function endpoints {
  kubectl get endpoints $KUBEALL $@
}

function configmaps {
  kubectl get configmaps $KUBEALL $@
}

function secrets {
  kubectl get secrets $KUBEALL $@
}

function certificates {
  kubectl get certificates $KUBEALL $@
}

function issuers {
  kubectl get issuers $KUBEALL $@
}

function orders {
  kubectl get orders $KUBEALL $@
}

function daemonsets {
  kubectl get daemonsets $KUBEALL $@
}

function statefulsets {
  kubectl get statefulsets $KUBEALL $@
}

function jobs {
  kubectl get jobs $KUBEALL $@
}

function cronjobs {
  kubectl get cronjobs $KUBEALL $@
}

function replicasets {
  kubectl get replicasets $KUBEALL $@
}

function persistentvolumeclaims {
  kubectl get persistentvolumeclaims $KUBEALL $@
}

function persistentvolumes {
  kubectl get persistentvolumes $@
}

function storageclasses {
  kubectl get storageclasses $@
}

function networkpolicies {
  kubectl get networkpolicies $KUBEALL $@
}

function serviceaccounts {
  kubectl get serviceaccounts $KUBEALL $@
}

function namespaces {
  kubectl get namespaces $@
}

# Shortcuts for listing resources
function deps { deployments "$@"; }
function svcs { services "$@"; }
function ings { ingresses "$@"; }
function eps { endpoints "$@"; }
function cms { configmaps "$@"; }
function certs { certificates "$@"; }
function ds { daemonsets "$@"; }
function sts { statefulsets "$@"; }
function cjs { cronjobs "$@"; }
function rs { replicasets "$@"; }
function pvcs { persistentvolumeclaims "$@"; }
function pvs { persistentvolumes "$@"; }
function sc { storageclasses "$@"; }
function netpols { networkpolicies "$@"; }
function sas { serviceaccounts "$@"; }
function nss { namespaces "$@"; }

# Shortcuts for individual resources
function dep { deployment "$@"; }
function svc { service "$@"; }
function ing { ingress "$@"; }
function ep { endpoint "$@"; }
function cm { configmap "$@"; }
function cert { certificate "$@"; }
function ds { daemonset "$@"; }
function sts { statefulset "$@"; }
function cj { cronjob "$@"; }
function rs { replicaset "$@"; }
function pvc { persistentvolumeclaim "$@"; }
function pv { persistentvolume "$@"; }
function netpol { networkpolicy "$@"; }
function sa { serviceaccount "$@"; }

function pod {
  namespace=$(khelper "$1")
  kubectl get pod -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this pod?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe pod -n "${namespace}" "$1"; break;;
      YAML ) kubectl get pod -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit pod -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete pod $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete pod -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function deployment {
  namespace=$(khelper "$1")
  kubectl get deployment -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this deployment?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete" "Restart"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe deployment -n "${namespace}" "$1"; break;;
      YAML ) kubectl get deployment -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit deployment -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete deployment $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete deployment -n "${namespace}" "$1"; fi; break;;
      Restart ) kubectl rollout restart deployment -n "${namespace}" "$1"; break;;
    esac
  done
}

function service {
  namespace=$(khelper "$1")
  kubectl get service -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this service?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe service -n "${namespace}" "$1"; break;;
      YAML ) kubectl get service -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit service -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete service $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete service -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function ingress {
  namespace=$(khelper "$1")
  kubectl get ingress -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this ingress?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe ingress -n "${namespace}" "$1"; break;;
      YAML ) kubectl get ingress -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit ingress -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete ingress $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete ingress -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function endpoint {
  namespace=$(khelper "$1")
  kubectl get endpoint -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this endpoint?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe endpoint -n "${namespace}" "$1"; break;;
      YAML ) kubectl get endpoint -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit endpoint -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete endpoint $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete endpoint -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function configmap {
  namespace=$(khelper "$1")
  kubectl get configmap -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this configmap?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete" "Recreate"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe configmap -n "${namespace}" "$1"; break;;
      YAML ) kubectl get configmap -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit configmap -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete configmap $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete configmap -n "${namespace}" "$1"; fi; break;;
      Recreate ) echo "Are you sure you want to recreate configmap $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then echo "Enter path to file:"; read file; kubectl create configmap "$1" -n "${namespace}" --from-file="$file" --dry-run=client -o yaml | kubectl apply -f -; fi; break;;
    esac
  done
}

function secret {
  namespace=$(khelper "$1")
  kubectl get secret -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this secret?"
  select yn in "Nothing" "Decode" "Delete" "Recreate"; do
    case $yn in
      Nothing ) break;;
      Decode ) kubectl get secret -n "${namespace}" "$1" -o jsonpath='{.data.*}' | base64 -d; break;;
      Delete ) echo "Are you sure you want to delete secret $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete secret -n "${namespace}" "$1"; fi; break;;
      Recreate ) echo "Are you sure you want to recreate secret $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then echo "Enter key:"; read key; echo "Enter value:"; read value; kubectl delete secret -n "${namespace}" "$1"; kubectl create secret generic "$1" -n "${namespace}" --from-literal="$key"="$value"; fi; break;;
    esac
  done
}

function certificate {
  namespace=$(khelper "$1")
  kubectl get certificate -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this certificate?"
  select action in "Nothing" "Describe" "YAML" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe certificate -n "${namespace}" "$1"; break;;
      YAML ) kubectl get certificate -n "${namespace}" "$1" -o yaml; break;;
      Delete ) echo "Are you sure you want to delete certificate $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete certificate -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function issuer {
  namespace=$(khelper "$1")
  kubectl get issuer -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this issuer?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe issuer -n "${namespace}" "$1"; break;;
      YAML ) kubectl get issuer -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit issuer -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete issuer $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete issuer -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function order {
  namespace=$(khelper "$1")
  kubectl get order -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this order?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe order -n "${namespace}" "$1"; break;;
      YAML ) kubectl get order -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit order -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete order $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete order -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function logs {
  namespace=$(khelper "$1")
  kubectl logs -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with these logs?"
  select action in "Nothing" "Follow" "Pager"; do
    case $action in
      Nothing ) break;;
      Follow ) kubectl logs -n "${namespace}" "$1" -f ${@:2}; break;;
      Pager ) kubectl logs -n "${namespace}" "$1" ${@:2} --force-colors | less -R; break;;
    esac
  done
}

function daemonset {
  namespace=$(khelper "$1")
  kubectl get daemonset -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this daemonset?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete" "Restart"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe daemonset -n "${namespace}" "$1"; break;;
      YAML ) kubectl get daemonset -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit daemonset -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete daemonset $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete daemonset -n "${namespace}" "$1"; fi; break;;
      Restart ) kubectl rollout restart daemonset -n "${namespace}" "$1"; break;;
    esac
  done
}

function statefulset {
  namespace=$(khelper "$1")
  kubectl get statefulset -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this statefulset?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete" "Restart"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe statefulset -n "${namespace}" "$1"; break;;
      YAML ) kubectl get statefulset -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit statefulset -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete statefulset $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete statefulset -n "${namespace}" "$1"; fi; break;;
      Restart ) kubectl rollout restart statefulset -n "${namespace}" "$1"; break;;
    esac
  done
}

function job {
  namespace=$(khelper "$1")
  kubectl get job -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this job?"
  select action in "Nothing" "Describe" "YAML" "Delete" "Logs"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe job -n "${namespace}" "$1"; break;;
      YAML ) kubectl get job -n "${namespace}" "$1" -o yaml; break;;
      Delete ) echo "Are you sure you want to delete job $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete job -n "${namespace}" "$1"; fi; break;;
      Logs ) kubectl logs -n "${namespace}" job/"$1"; break;;
    esac
  done
}

function cronjob {
  namespace=$(khelper "$1")
  kubectl get cronjob -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this cronjob?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete" "Suspend" "Resume" "Trigger"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe cronjob -n "${namespace}" "$1"; break;;
      YAML ) kubectl get cronjob -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit cronjob -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete cronjob $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete cronjob -n "${namespace}" "$1"; fi; break;;
      Suspend ) kubectl patch cronjob -n "${namespace}" "$1" -p '{"spec":{"suspend":true}}'; break;;
      Resume ) kubectl patch cronjob -n "${namespace}" "$1" -p '{"spec":{"suspend":false}}'; break;;
      Trigger ) kubectl create job --from=cronjob/"$1" "$1-manual-$(date +%s)" -n "${namespace}"; break;;
    esac
  done
}

function replicaset {
  namespace=$(khelper "$1")
  kubectl get replicaset -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this replicaset?"
  select action in "Nothing" "Describe" "YAML" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe replicaset -n "${namespace}" "$1"; break;;
      YAML ) kubectl get replicaset -n "${namespace}" "$1" -o yaml; break;;
      Delete ) echo "Are you sure you want to delete replicaset $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete replicaset -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function persistentvolumeclaim {
  namespace=$(khelper "$1")
  kubectl get persistentvolumeclaim -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this PVC?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe persistentvolumeclaim -n "${namespace}" "$1"; break;;
      YAML ) kubectl get persistentvolumeclaim -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit persistentvolumeclaim -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete PVC $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete persistentvolumeclaim -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function persistentvolume {
  kubectl get persistentvolume "$1" ${@:2}

  echo "What would you like to do with this PV?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe persistentvolume "$1"; break;;
      YAML ) kubectl get persistentvolume "$1" -o yaml; break;;
      Edit ) kubectl edit persistentvolume "$1"; break;;
      Delete ) echo "Are you sure you want to delete PV $1? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete persistentvolume "$1"; fi; break;;
    esac
  done
}

function storageclass {
  kubectl get storageclass "$1" ${@:2}

  echo "What would you like to do with this storageclass?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe storageclass "$1"; break;;
      YAML ) kubectl get storageclass "$1" -o yaml; break;;
      Edit ) kubectl edit storageclass "$1"; break;;
      Delete ) echo "Are you sure you want to delete storageclass $1? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete storageclass "$1"; fi; break;;
    esac
  done
}

function networkpolicy {
  namespace=$(khelper "$1")
  kubectl get networkpolicy -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this network policy?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe networkpolicy -n "${namespace}" "$1"; break;;
      YAML ) kubectl get networkpolicy -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit networkpolicy -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete network policy $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete networkpolicy -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function serviceaccount {
  namespace=$(khelper "$1")
  kubectl get serviceaccount -n "${namespace}" "$1" ${@:2}

  echo "What would you like to do with this service account?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe serviceaccount -n "${namespace}" "$1"; break;;
      YAML ) kubectl get serviceaccount -n "${namespace}" "$1" -o yaml; break;;
      Edit ) kubectl edit serviceaccount -n "${namespace}" "$1"; break;;
      Delete ) echo "Are you sure you want to delete service account $1 in namespace $namespace? (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete serviceaccount -n "${namespace}" "$1"; fi; break;;
    esac
  done
}

function namespace {
  kubectl get namespace "$1" ${@:2}

  echo "What would you like to do with this namespace?"
  select action in "Nothing" "Describe" "YAML" "Edit" "Delete"; do
    case $action in
      Nothing ) break;;
      Describe ) kubectl describe namespace "$1"; break;;
      YAML ) kubectl get namespace "$1" -o yaml; break;;
      Edit ) kubectl edit namespace "$1"; break;;
      Delete ) echo "Are you sure you want to delete namespace $1? This will delete ALL resources in the namespace! (yes/no)"; read confirm; if [ "$confirm" = "yes" ]; then kubectl delete namespace "$1"; fi; break;;
    esac
  done
}

function node {
  kubectl get node "$1" ${@:2}

  echo "Do you want to describe this node?"
  select yn in "Nothing" "Yes"; do
    case $yn in
      Nothing ) break;;
      Describe ) kubectl describe node "$1"; break;;

    esac
  done
}

function install-nginx {
  local provider="${1:-generic}"

  echo "Installing NGINX Ingress Controller"

  helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx 2>/dev/null
  helm repo update

  case "$provider" in
    azure|aks)
      echo "Using Azure/AKS configuration..."
      helm install ingress-nginx ingress-nginx/ingress-nginx \
        --create-namespace \
        --namespace ingress-nginx \
        --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
      ;;
    *)
      echo "Using generic configuration..."
      helm install ingress-nginx ingress-nginx/ingress-nginx \
        --create-namespace \
        --namespace ingress-nginx
      ;;
  esac

  echo ""
  echo "NGINX Ingress Controller installed. To check status:"
  echo "  kubectl get pods -n ingress-nginx"
}

# Bash Completions
# Completion for functions that take pod names
_kube_pod_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local pods=$(kubectl get pods --no-headers 2>/dev/null | awk '{print $1}')
  COMPREPLY=($(compgen -W "${pods}" -- "${cur}"))
}

# Completion for functions that take deployment names
_kube_deployment_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local deployments=$(kubectl get deployments --no-headers 2>/dev/null | awk '{print $1}')
  COMPREPLY=($(compgen -W "${deployments}" -- "${cur}"))
}

# Completion for functions that take service names
_kube_service_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local services=$(kubectl get services --no-headers 2>/dev/null | awk '{print $1}')
  COMPREPLY=($(compgen -W "${services}" -- "${cur}"))
}

# Completion for functions that take any resource name (searches all namespaces)
_kube_resource_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local resource_type="${1:-${FUNCNAME[1]%_completion}}"
  # Pluralize if needed
  case "$resource_type" in
    pod|deployment|service|ingress|endpoint|configmap|secret|certificate|issuer|order|daemonset|statefulset|job|cronjob|replicaset|persistentvolumeclaim|networkpolicy|serviceaccount)
      resource_type="${resource_type}s"
      ;;
  esac
  local resources=$(kubectl get "$resource_type" -A --no-headers 2>/dev/null | awk '{print $2}')
  COMPREPLY=($(compgen -W "${resources}" -- "${cur}"))
}

# Completion for namespace function
_kube_namespace_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local namespaces=$(kubectl get namespaces --no-headers 2>/dev/null | awk '{print $1}')
  COMPREPLY=($(compgen -W "${namespaces}" -- "${cur}"))
}

# Completion for node function
_kube_node_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local nodes=$(kubectl get nodes --no-headers 2>/dev/null | awk '{print $1}')
  COMPREPLY=($(compgen -W "${nodes}" -- "${cur}"))
}

# Completion for watch function
_kube_watch_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local resources="pods deployments services nodes events ingresses endpoints configmaps secrets certificates issuers orders daemonsets statefulsets jobs cronjobs replicasets persistentvolumeclaims persistentvolumes storageclasses networkpolicies serviceaccounts namespaces"
  COMPREPLY=($(compgen -W "${resources}" -- "${cur}"))
}

# Completion for kubeall function
_kube_kubeall_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=($(compgen -W "on off" -- "${cur}"))
}

# Register completions
complete -F _kube_pod_completion pod exec logs
complete -F _kube_deployment_completion deployment dep rollout
complete -F _kube_service_completion service svc
complete -F _kube_resource_completion ingress ing endpoint ep configmap cm secret certificate cert issuer order daemonset statefulset sts job cronjob cj replicaset rs persistentvolumeclaim pvc
complete -F _kube_node_completion node
complete -F _kube_namespace_completion ns namespace
complete -F _kube_watch_completion watch
complete -F _kube_kubeall_completion kubeall

# For cluster-wide resources
complete -F _kube_node_completion persistentvolume pv
complete -F _kube_resource_completion storageclass networkpolicy netpol serviceaccount sa

# Initial state
echo "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣶⠿⠻⢷⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠘⠿⢻⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣧⣄⣀⣤⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⡿⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣉⡉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣦⣤⣤⣤⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀
⠀⢀⣴⣿⣿⣿⣿⡿⠿⠛⠛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⢿⣦⡀⠀⠀
⠀⣾⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠉⢿⡄⠀
⢸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠸⡿⠀⢸⣿⣿⣿⣿⣿⣿⣤⡀⠀⠰⣿⠆⢸⡷⠀
⠸⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⣠⣿⣿⣿⠁⣠⣤⣄⢈⣿⣆⡀⠀⣠⡾⠃⠀
⠀⢻⣿⣿⣿⣿⣿⣿⡶⠶⠿⠛⠛⠛⠛⠛⠉⠁⠉⠉⠉⠈⠉⠛⠛⠛⠿⠷⣦⡀
⠀⠀⠙⢿⣿⣿⠋⠁⠀⣠⣶⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣴⡶⠿⠛⠁
⠀⠀⠀⠀⠙⠻⣦⣀⠀⠈⠀⠀⠙⣿⡇⠈⠉⠉⠉⠉⣉⣥⣴⢿⡿⠃⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠙⠻⠶⠶⣶⣦⣤⣴⣶⡶⠶⠾⠟⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀"
kubeall on